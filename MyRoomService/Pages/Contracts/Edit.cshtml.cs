using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.AspNetCore.Mvc.Rendering;
using Microsoft.EntityFrameworkCore;
using MyRoomService.Domain.Entities;
using MyRoomService.Domain.Interfaces;
using MyRoomService.Infrastructure.Persistence;
// Ensure you have your Services namespace included for ITenantService
using System.Text.Json;

namespace MyRoomService.Pages.Contracts
{
    public class EditModel : PageModel
    {
        private readonly ApplicationDbContext _context;
        private readonly ITenantService _tenantService;

        public EditModel(ApplicationDbContext context, ITenantService tenantService)
        {
            _context = context;
            _tenantService = tenantService;
        }

        [BindProperty]
        public Contract Contract { get; set; }

        // This catches the array of hidden inputs generated by our JavaScript!
        [BindProperty]
        public List<AddOnInputModel> SelectedAddOns { get; set; } = new();

        // UI Display Properties
        public string OccupantName { get; set; }
        public string UnitDisplayName { get; set; }
        public string AvailableAddOnsJson { get; set; }
        public List<ExistingAddOnViewModel> ExistingAddOns { get; set; } = new();
        public SelectList ContractStatusOptions { get; set; }
        public async Task<IActionResult> OnGetAsync(Guid id)
        {
            var tenantId = _tenantService.GetTenantId();
            ContractStatusOptions = new SelectList(
            Enum.GetValues<ContractStatus>()
                .Where(s => s != ContractStatus.Ended && s != ContractStatus.Terminated)
                .Select(s => new { Value = (int)s, Text = s.ToString() }),
            "Value", "Text"
    );
            // 1. Fetch the Contract with ALL its related data
            var contract = await _context.Contracts
                .Include(c => c.Occupant)
                .Include(c => c.Unit)
                    .ThenInclude(u => u.Building) // Get the building name too!
                .Include(c => c.AddOns)
                    .ThenInclude(a => a.ChargeDefinition)
                .FirstOrDefaultAsync(c => c.Id == id && c.TenantId == tenantId);

            if (contract == null)
            {
                return NotFound("Contract not found or access denied.");
            }

            Contract = contract;

            // 2. Format the display names for the locked fields
            OccupantName = $"{contract.Occupant.FirstName} {contract.Occupant.LastName}";
            UnitDisplayName = $"{contract.Unit.Building.Name} - {contract.Unit.UnitNumber}";

            // 3. Map the existing Add-ons to our View Model to display in the HTML table
            ExistingAddOns = contract.AddOns.Select(a => new ExistingAddOnViewModel
            {
                ChargeDefinitionId = a.ChargeDefinitionId,
                ChargeName = a.ChargeDefinition.Name,
                ChargeType = a.ChargeDefinition.ChargeType,
                AgreedAmount = a.AgreedAmount
            }).ToList();

            // 4. Load available charges for the Modal
            var availableCharges = await _context.ChargeDefinitions
                .Where(c => c.TenantId == tenantId)
                .Select(c => new
                {
                    Id = c.Id,
                    Name = c.Name,
                    ChargeType = c.ChargeType,
                    DefaultAmount = c.DefaultAmount
                })
                .ToListAsync();

            AvailableAddOnsJson = JsonSerializer.Serialize(availableCharges);

            return Page();
        }

        public async Task<IActionResult> OnPostAsync()
        {
            var tenantId = _tenantService.GetTenantId();

            // 1. THE SAFE APPROACH: Fetch the real entity from the DB first.
            // We Include the AddOns because we are going to modify them.
            var contractToUpdate = await _context.Contracts
                .Include(c => c.AddOns)
                .FirstOrDefaultAsync(c => c.Id == Contract.Id && c.TenantId == tenantId);

            if (contractToUpdate == null) return NotFound();

            // 2. SAFELY map only the allowed fields. 
            // Notice we do NOT map UnitId or OccupantId. They stay locked in the DB.
            // Force the incoming Unspecified dates to be treated as UTC for PostgreSQL
            contractToUpdate.StartDate = DateTime.SpecifyKind(Contract.StartDate, DateTimeKind.Utc);

            if (Contract.EndDate.HasValue)
            {
                contractToUpdate.EndDate = DateTime.SpecifyKind(Contract.EndDate.Value, DateTimeKind.Utc);
            }
            else
            {
                contractToUpdate.EndDate = null;
            }
            contractToUpdate.RentAmount = Contract.RentAmount;
            contractToUpdate.BillingDay = Contract.BillingDay;
            contractToUpdate.Status = Contract.Status;

            // 3. HANDLE ADD-ONS (The EF Core Magic Way)
            // First, clear out the old list of add-ons entirely.
            contractToUpdate.AddOns.Clear();

            // Then, rebuild the list with whatever came from the HTML form.
            if (SelectedAddOns != null && SelectedAddOns.Any())
            {
                foreach (var addon in SelectedAddOns)
                {
                    contractToUpdate.AddOns.Add(new ContractAddOn
                    {
                        TenantId = tenantId,
                        ChargeDefinitionId = addon.ChargeDefinitionId,
                        AgreedAmount = addon.AgreedAmount
                    });
                }
            }

            // 4. Save changes. EF Core is smart enough to issue DELETEs for the removed add-ons
            // and INSERTs for the new ones automatically.
            await _context.SaveChangesAsync();

            // Redirect back to the index page for this occupant
            return RedirectToPage("/Contracts/Index", new { occupantId = contractToUpdate.OccupantId });
        }
    }

    // --- HELPER CLASSES ---

    // Used to catch data coming from the HTML form POST
    public class AddOnInputModel
    {
        public Guid ChargeDefinitionId { get; set; }
        public decimal AgreedAmount { get; set; }
    }

    // Used to send data to the HTML view to render the table
    public class ExistingAddOnViewModel
    {
        public Guid ChargeDefinitionId { get; set; }
        public string ChargeName { get; set; }
        public string ChargeType { get; set; }
        public decimal AgreedAmount { get; set; }
    }
}